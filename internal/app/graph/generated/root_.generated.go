// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/fidesy-pay/facade/internal/pkg/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Invoice() InvoiceResolver
	InvoiceMutations() InvoiceMutationsResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CheckInvoicePayload struct {
		Invoice func(childComplexity int) int
	}

	CreateInvoicePayload struct {
		ID func(childComplexity int) int
	}

	Invoice struct {
		Address   func(childComplexity int) int
		Amount    func(childComplexity int) int
		Chain     func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Id        func(childComplexity int) int
		Status    func(childComplexity int) int
		Token     func(childComplexity int) int
	}

	InvoiceMutations struct {
		CheckInvoice  func(childComplexity int, input model.CheckInvoiceInput) int
		CreateInvoice func(childComplexity int) int
		UpdateInvoice func(childComplexity int, input model.UpdateInvoiceInput) int
	}

	LoginPayload struct {
		Token func(childComplexity int) int
	}

	Mutation struct {
		InvoiceMutations func(childComplexity int) int
		Login            func(childComplexity int, input model.LoginInput) int
		SignUp           func(childComplexity int, input model.SignUpInput) int
	}

	Query struct {
		Test func(childComplexity int) int
	}

	SignUpPayload struct {
		Token func(childComplexity int) int
	}

	TokenClaims struct {
		Username func(childComplexity int) int
	}

	UpdateInvoicePayload struct {
		Invoice func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CheckInvoicePayload.invoice":
		if e.complexity.CheckInvoicePayload.Invoice == nil {
			break
		}

		return e.complexity.CheckInvoicePayload.Invoice(childComplexity), true

	case "CreateInvoicePayload.id":
		if e.complexity.CreateInvoicePayload.ID == nil {
			break
		}

		return e.complexity.CreateInvoicePayload.ID(childComplexity), true

	case "Invoice.address":
		if e.complexity.Invoice.Address == nil {
			break
		}

		return e.complexity.Invoice.Address(childComplexity), true

	case "Invoice.amount":
		if e.complexity.Invoice.Amount == nil {
			break
		}

		return e.complexity.Invoice.Amount(childComplexity), true

	case "Invoice.chain":
		if e.complexity.Invoice.Chain == nil {
			break
		}

		return e.complexity.Invoice.Chain(childComplexity), true

	case "Invoice.created_at":
		if e.complexity.Invoice.CreatedAt == nil {
			break
		}

		return e.complexity.Invoice.CreatedAt(childComplexity), true

	case "Invoice.id":
		if e.complexity.Invoice.Id == nil {
			break
		}

		return e.complexity.Invoice.Id(childComplexity), true

	case "Invoice.status":
		if e.complexity.Invoice.Status == nil {
			break
		}

		return e.complexity.Invoice.Status(childComplexity), true

	case "Invoice.token":
		if e.complexity.Invoice.Token == nil {
			break
		}

		return e.complexity.Invoice.Token(childComplexity), true

	case "InvoiceMutations.checkInvoice":
		if e.complexity.InvoiceMutations.CheckInvoice == nil {
			break
		}

		args, err := ec.field_InvoiceMutations_checkInvoice_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InvoiceMutations.CheckInvoice(childComplexity, args["input"].(model.CheckInvoiceInput)), true

	case "InvoiceMutations.createInvoice":
		if e.complexity.InvoiceMutations.CreateInvoice == nil {
			break
		}

		return e.complexity.InvoiceMutations.CreateInvoice(childComplexity), true

	case "InvoiceMutations.updateInvoice":
		if e.complexity.InvoiceMutations.UpdateInvoice == nil {
			break
		}

		args, err := ec.field_InvoiceMutations_updateInvoice_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.InvoiceMutations.UpdateInvoice(childComplexity, args["input"].(model.UpdateInvoiceInput)), true

	case "LoginPayload.token":
		if e.complexity.LoginPayload.Token == nil {
			break
		}

		return e.complexity.LoginPayload.Token(childComplexity), true

	case "Mutation.invoiceMutations":
		if e.complexity.Mutation.InvoiceMutations == nil {
			break
		}

		return e.complexity.Mutation.InvoiceMutations(childComplexity), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.LoginInput)), true

	case "Mutation.signUp":
		if e.complexity.Mutation.SignUp == nil {
			break
		}

		args, err := ec.field_Mutation_signUp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SignUp(childComplexity, args["input"].(model.SignUpInput)), true

	case "Query.test":
		if e.complexity.Query.Test == nil {
			break
		}

		return e.complexity.Query.Test(childComplexity), true

	case "SignUpPayload.token":
		if e.complexity.SignUpPayload.Token == nil {
			break
		}

		return e.complexity.SignUpPayload.Token(childComplexity), true

	case "TokenClaims.username":
		if e.complexity.TokenClaims.Username == nil {
			break
		}

		return e.complexity.TokenClaims.Username(childComplexity), true

	case "UpdateInvoicePayload.invoice":
		if e.complexity.UpdateInvoicePayload.Invoice == nil {
			break
		}

		return e.complexity.UpdateInvoicePayload.Invoice(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCheckInvoiceInput,
		ec.unmarshalInputLoginInput,
		ec.unmarshalInputSignUpInput,
		ec.unmarshalInputUpdateInvoiceInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../api/graphql/directives/goModel.graphql", Input: `directive @goModel(model: String, models: [String!]) on OBJECT
    | INPUT_OBJECT
    | SCALAR
    | ENUM
    | INTERFACE
    | UNION`, BuiltIn: false},
	{Name: "../../../../api/graphql/enum/invoice_status.graphql", Input: `enum InvoiceStatus {
  UNKNOWN_STATUS
  NEW
  PENDING
  FAILED
  SUCCESS
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/mutation/invoice.mutation.graphql", Input: `extend type Mutation {
    invoiceMutations: InvoiceMutations!
}

type InvoiceMutations {
    createInvoice: CreateInvoicePayload!
    updateInvoice(input: UpdateInvoiceInput!): UpdateInvoicePayload!
    checkInvoice(input: CheckInvoiceInput!): CheckInvoicePayload!
}

type CreateInvoicePayload {
    id: String!
}

input UpdateInvoiceInput {
    id: String!
    amount: Float!
    chain: String!
    token: String!
}

type UpdateInvoicePayload {
    invoice: Invoice!
}

input CheckInvoiceInput {
    id: String!
}

type CheckInvoicePayload {
    invoice: Invoice!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/mutation/login.graphql", Input: `extend type Mutation {
    login(input: LoginInput!): LoginPayload!
}

input LoginInput {
    username: String!
    password: String!
}

type LoginPayload {
    token: String!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/mutation/signup.graphql", Input: `extend type Mutation {
    signUp(input: SignUpInput!): SignUpPayload!
}

input SignUpInput {
    username: String!
    password: String!
}

type SignUpPayload {
    token: String!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/query/test.query.graphql", Input: `extend type Query {
    test: String!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/scalars.graphql", Input: `scalar Time`, BuiltIn: false},
	{Name: "../../../../api/graphql/schema/schema.graphql", Input: `schema {
    query: Query
    mutation: Mutation
}

type Query

type Mutation`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/invoice.graphql", Input: `type Invoice @goModel(model: "github.com/fidesy-pay/facade/pkg/invoices-service.Invoice") {
    id: String!
    amount: Float!
    chain: String!
    token: String!
    status: InvoiceStatus!
    address: String!
    created_at: Time!
}`, BuiltIn: false},
	{Name: "../../../../api/graphql/types/token_claims.graphql", Input: `type TokenClaims @goModel(model: "github.com/fidesy-pay/facade/pkg/auth-service.TokenClaims") {
    username: String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
